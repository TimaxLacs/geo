# План работ по проекту "Гео" (TimaxLax Geo)

## Обзор проекта

**Цель:** Создать универсальный React-компонент для работы с картографическими сервисами (Яндекс.Карты, Google Maps, 2GIS) с возможностью публикации в npm как библиотека.

**Основная концепция:** Компонент `<Geo>` должен быть универсальным движком отрисовки карт, поддерживающим различные картографические провайдеры через единый API.

---

## Этап 1: Настройка проекта и инфраструктуры

### 1.1 Инициализация проекта
- [x] Создать git-репозиторий с названием "geo"
- [x] Выполнить `npx hasyx init` для инициализации Hasyx
- [x] Настроить переменные окружения в `.env`:
  ```
  NEXT_PUBLIC_HASURA_GRAPHQL_URL=https://your-hasura-instance.herokuapp.com/v1/graphql
  NEXT_PUBLIC_MAIN_URL=http://localhost:3000
  ```
- [x] Убедиться, что созданы все необходимые файлы:
  - [x] `tsconfig.json` и `tsconfig.lib.json` (с правильными путями для проекта)
  - [x] `package.json` с правильным именем проекта
  - [x] `next.config.ts` с WebSocket поддержкой
  - [x] `components.json` для shadcn/ui
  - [x] `.gitignore`, `.npmignore`, `.npmrc`
  - [x] `Dockerfile` и `.dockerignore`
  - [x] `vercel.json` для деплоя
  - [x] `jest.config.mjs` и `babel.jest.config.mjs` для тестов

### 1.2 Настройка через Hasyx Assistant
- [x] Запустить `npx hasyx assist`
- [x] Настроить все токены (кроме БД - пропустить):
  - [x] Telegram Bot токены
  - [x] Vercel интеграция
  - [x] GitHub токены
  - [x] Другие необходимые API ключи
- [x] Настроить автоматическую загрузку environment variables в GitHub
- [ ] Интегрировать с Vercel для синхронизации *(требует донастройки VERCEL_ORG_ID и VERCEL_PROJECT_ID)*
- [x] Настроить GitHub Actions для автоматической публикации в npm
- [ ] Настроить Docker Hub интеграцию (если требуется) *(логин/токен не введены)*

### 1.3 Переименование и брендинг
- [ ] Переименовать проект с "hasyx" на "geo" (TimaxLax Geo)
- [ ] Заменить логотип Hasyx на собственный логотип
- [ ] Обновить все упоминания бренда в коде и документации
- [ ] Настроить отображение нового логотипа на главной странице
- [ ] Обновить `package.json` с новым именем и описанием
- [ ] Обновить `app/sidebar.ts` с новым названием проекта
- [ ] Обновить `app/page.tsx` для отображения нового логотипа
- [ ] Обновить все пути в `tsconfig.json` и `tsconfig.lib.json`

---


## Этап 2: Изучение и анализ картографических API

### 2.1 Анализ поддерживаемых сервисов
- [ ] **Яндекс.Карты**: изучить API, возможности, ограничения
- [ ] **Google Maps**: изучить API, возможности, ограничения  
- [ ] **2GIS**: изучить API, возможности, ограничения
- [ ] Создать сравнительную таблицу возможностей каждого сервиса

### 2.2 Изучение стандартов геоданных
- [ ] Исследовать стандарты центральных точек и значений геоданных
- [ ] Создать универсальный конвертер координат
- [ ] Определить общий формат для работы с координатами
- [ ] Изучить различные системы координат (WGS84, GCJ-02, BD-09 и др.)

---

## Этап 3: Архитектура и структура проекта

### 3.1 Структура папок
```
lib/
├── yandex/
│   ├── index.ts (класс YandexGeoProvider)
│   ├── types.ts
│   └── tests/
├── google/
│   ├── index.ts (класс GoogleGeoProvider)
│   ├── types.ts
│   └── tests/
├── twogis/
│   ├── index.ts (класс TwoGisGeoProvider)
│   ├── types.ts
│   └── tests/
├── core/
│   ├── GeoProvider.ts (базовый класс)
│   ├── types.ts (общие типы)
│   └── converters.ts (конвертеры координат)
└── components/
    ├── Geo.tsx (основной компонент)
    ├── GeoMarker.tsx
    ├── GeoPolygon.tsx
    └── GeoRoute.tsx

components/
├── ui/ (shadcn/ui компоненты)
├── geo/
│   ├── geo-provider.tsx (Context Provider для карт)
│   ├── geo-controls.tsx (панель управления)
│   ├── geo-search.tsx (поиск адресов)
│   └── geo-diagnostics.tsx (диагностическая панель)

app/
├── api/geo/
│   ├── yandex/
│   │   ├── search.ts
│   │   ├── geocode.ts
│   │   └── reverse-geocode.ts
│   ├── google/
│   │   ├── search.ts
│   │   ├── geocode.ts
│   │   └── reverse-geocode.ts
│   └── twogis/
│       ├── search.ts
│       ├── geocode.ts
│       └── reverse-geocode.ts
└── geo/
    └── page.tsx (главная страница с демо)
```

### 3.2 Базовый класс GeoProvider
Каждый провайдер должен реализовывать:
- [ ] `getBounds()` - получение границ карты
- [ ] `disablePosition()` - отключение изменения позиции
- [ ] `disableZoom()` - отключение зума
- [ ] `searchAddress(query: string)` - поиск по адресу
- [ ] `searchCoordinates(lat: number, lng: number)` - поиск по координатам
- [ ] `addMarker(marker: MarkerData)` - добавление маркера
- [ ] `removeMarker(id: string)` - удаление маркера
- [ ] `addPolygon(polygon: PolygonData)` - добавление полигона
- [ ] `addRoute(route: RouteData)` - добавление маршрута
- [ ] `setCenter(lat: number, lng: number)` - установка центра карты
- [ ] `setZoom(level: number)` - установка уровня зума
- [ ] `getCenter()` - получение текущего центра
- [ ] `getZoom()` - получение текущего зума
- [ ] `onBoundsChange(callback: (bounds: Bounds) => void)` - событие изменения границ
- [ ] `onCenterChange(callback: (center: LatLng) => void)` - событие изменения центра
- [ ] `onZoomChange(callback: (zoom: number) => void)` - событие изменения зума

---

## Этап 4: Реализация провайдеров (поэтапно)

### 4.1 Яндекс.Карты (первый этап)
- [ ] Создать класс `YandexGeoProvider`
- [ ] Реализовать базовые методы карты
- [ ] Добавить поддержку маркеров
- [ ] Написать Jest тесты
- [ ] Создать API роуты для работы с Яндекс API:
  ```
  /api/geo/yandex/search
  /api/geo/yandex/geocode
  /api/geo/yandex/reverse-geocode
  ```
- [ ] Интегрировать с Hasyx системой событий
- [ ] Добавить поддержку WebSocket для real-time обновлений
- [ ] Использовать Hasyx ExecTs для динамического выполнения кода
- [ ] Настроить логирование через Hasyx debug систему

### 4.2 Google Maps
- [ ] Создать класс `GoogleGeoProvider`
- [ ] Реализовать те же методы, что и для Яндекс
- [ ] Написать Jest тесты
- [ ] Создать API роуты для работы с Google API
- [ ] Интегрировать с Hasyx системой событий
- [ ] Добавить поддержку WebSocket для real-time обновлений
- [ ] Использовать Hasyx ExecTs для динамического выполнения кода
- [ ] Настроить логирование через Hasyx debug систему

### 4.3 2GIS
- [ ] Создать класс `TwoGisGeoProvider`
- [ ] Реализовать методы для работы с 2GIS API
- [ ] Написать Jest тесты
- [ ] Создать API роуты для работы с 2GIS API
- [ ] Интегрировать с Hasyx системой событий
- [ ] Добавить поддержку WebSocket для real-time обновлений
- [ ] Использовать Hasyx ExecTs для динамического выполнения кода
- [ ] Настроить логирование через Hasyx debug систему

---

## Этап 5: Основной компонент Geo

### 5.1 Базовая структура компонента
```tsx
<Geo 
  provider="yandex" | "google" | "2gis"
  center={{ lat: number, lng: number }}
  zoom={number}
  disablePosition={boolean}
  disableZoom={boolean}
  onBoundsChange={(bounds) => void}
>
  <GeoMarker />
  <GeoPolygon />
  <GeoRoute />
</Geo>
```

### 5.2 Система провайдеров
- [ ] Реализовать динамическое переключение провайдеров
- [ ] При смене провайдера создавать новый экземпляр соответствующего класса
- [ ] Обеспечить сохранение состояния при переключении
- [ ] Реализовать Context API для передачи провайдера дочерним компонентам
- [ ] Интегрировать с Hasyx Provider системой
- [ ] Использовать Hasyx useHasyx hook для доступа к провайдеру
- [ ] Добавить поддержку Hasyx событий для обновления состояния
- [ ] Реализовать кэширование провайдеров через Hasyx систему

### 5.3 Управление состоянием
- [ ] Реализовать состояние карты (центр, зум, границы)
- [ ] Добавить возможность блокировки позиции и зума
- [ ] Создать систему событий для обновления состояния
- [ ] Использовать Hasyx useQuery и useSubscription для real-time данных
- [ ] Интегрировать с Hasyx системой миграций для сохранения состояния
- [ ] Добавить поддержку Hasyx логирования для отладки состояния
- [ ] Реализовать синхронизацию состояния через WebSocket

---

## Этап 6: Компоненты маркеров

### 6.1 GeoMarker компонент
- [ ] Создать компонент `<GeoMarker>`
- [ ] Реализовать провайдер для маркеров через Context
- [ ] Поддержка различных типов иконок для каждого провайдера
- [ ] Возможность кастомизации маркеров
- [ ] События клика, наведения и т.д.

### 6.2 Исследование возможностей маркеров
- [ ] Изучить возможности маркеров в каждом API
- [ ] Создать универсальный интерфейс для маркеров
- [ ] Поддержка кастомных иконок
- [ ] Анимации маркеров
- [ ] Информационные окна (popup)

---

## Этап 7: Полигоны и маршруты

### 7.1 GeoPolygon компонент
- [ ] Изучить возможности отрисовки векторных зон
- [ ] Создать универсальный компонент для полигонов
- [ ] Поддержка различных стилей отрисовки
- [ ] Возможность редактирования полигонов

### 7.2 GeoRoute компонент
- [ ] Создать компонент для отрисовки маршрутов
- [ ] Поддержка построения маршрутов между точками
- [ ] Различные типы маршрутов (пешком, на машине, на транспорте)
- [ ] Отображение времени и расстояния

---

## Этап 8: Главная страница и интерфейс

### 8.1 Структура главной страницы
- [ ] **Левая панель управления:**
  - Выбор провайдера карт
  - Настройки центра и зума
  - Чекбоксы для включения/отключения функций
  - Поле поиска адреса с мультиселектом
  - Управление маркерами (кнопка "+")
  
- [ ] **Центральная область:**
  - Демонстрация работы карты
  - Интерактивная карта с выбранными настройками
  
- [ ] **Правая панель:**
  - Генератор кода компонента
  - Шаблон кода, соответствующий настройкам

### 8.2 Интеграция с Hasyx
- [ ] Использовать `SidebarLayout` из Hasyx для общей структуры
- [ ] Интегрировать с Hasyx системой аутентификации
- [ ] Добавить поддержку Hasyx PWA функций
- [ ] Использовать Hasyx компоненты UI (shadcn/ui)
- [ ] Интегрировать с Hasyx системой уведомлений
- [ ] Добавить поддержку Hasyx Telegram Mini App
- [ ] Использовать Hasyx систему логирования для отладки

### 8.3 Компоненты интерфейса
- [ ] Использовать shadcn/ui для всех компонентов
- [ ] Создать мультиселект для поиска адресов
- [ ] Панель диагностики с разделами:
  - Маркеры (с кнопкой "+" для создания)
  - Полигоны
  - Маршруты
- [ ] Отображение координат и зума в реальном времени
- [ ] Интегрировать с Hasyx системой диагностики
- [ ] Использовать Hasyx компоненты для форм и валидации
- [ ] Добавить поддержку Hasyx темной/светлой темы

---

## Этап 9: API роуты и безопасность

### 9.1 Создание API роутов
```
/api/geo/
├── yandex/
│   ├── search.ts
│   ├── geocode.ts
│   └── reverse-geocode.ts
├── google/
│   ├── search.ts
│   ├── geocode.ts
│   └── reverse-geocode.ts
└── twogis/
    ├── search.ts
    ├── geocode.ts
    └── reverse-geocode.ts
```

### 9.2 Безопасность
- [ ] **ВАЖНО:** Не передавать API токены на клиент
- [ ] Все запросы к картографическим API делать через серверные роуты
- [ ] Использовать axios для запросов с сервера
- [ ] Добавить валидацию входных данных
- [ ] Реализовать кэширование результатов
- [ ] Интегрировать с Hasyx системой аутентификации для защиты API
- [ ] Использовать Hasyx JWT систему для авторизации
- [ ] Добавить поддержку Hasyx ролей и разрешений
- [ ] Использовать Hasyx систему логирования для аудита запросов

---

## Этап 10: Тестирование

### 10.1 Jest тесты
- [ ] Тесты для каждого провайдера
- [ ] Тесты конвертеров координат
- [ ] Тесты API роутов
- [ ] Тесты компонентов (React Testing Library)
- [ ] Интегрировать с Hasyx системой тестирования
- [ ] Использовать Hasyx ExecTs для тестирования динамического кода
- [ ] Добавить тесты для Hasyx интеграций
- [ ] Настроить тесты для WebSocket функциональности

### 10.2 E2E тесты
- [ ] Тестирование переключения провайдеров
- [ ] Тестирование добавления/удаления маркеров
- [ ] Тестирование поиска адресов
- [ ] Тестирование генератора кода

---

## Этап 11: Документация

### 11.1 README.md
- [ ] Описание проекта и возможностей
- [ ] Инструкции по установке
- [ ] Примеры использования
- [ ] Список необходимых environment variables
- [ ] API документация

### 11.2 Документация компонентов
- [ ] Документация для каждого компонента
- [ ] Примеры кода
- [ ] Описание пропсов и событий
- [ ] Миграционные гайды

---

## Этап 12: Публикация

### 12.1 Подготовка к публикации
- [ ] Настроить package.json для npm
- [ ] Создать index.ts с экспортами
- [ ] Настроить TypeScript конфигурацию
- [ ] Добавить .npmignore файл
- [ ] Использовать Hasyx систему сборки (`npm run build:lib`)
- [ ] Настроить Hasyx CLI команды для проекта
- [ ] Интегрировать с Hasyx системой документации
- [ ] Настроить Hasyx GitHub Actions для автоматической публикации

### 12.2 Публикация
- [ ] Запушить код в GitHub
- [ ] Создать релиз с версией 0.0.0
- [ ] Опубликовать в npm как `@timaxlax/geo`
- [ ] Настроить автоматическую публикацию через GitHub Actions

---

## Технические требования

### Environment Variables
```
# Обязательные
NEXT_PUBLIC_HASURA_GRAPHQL_URL=
NEXT_PUBLIC_MAIN_URL=

# Яндекс.Карты
YANDEX_MAPS_API_KEY=

# Google Maps
GOOGLE_MAPS_API_KEY=

# 2GIS
TWOGIS_API_KEY=
```

### Зависимости
- Next.js (App Router)
- React
- TypeScript
- Jest
- shadcn/ui
- axios
- Hasyx (как основа)
- @apollo/client (для GraphQL)
- next-auth (для аутентификации)
- lucide-react (для иконок)
- tailwindcss (для стилей)
- cytoscape (для визуализации графов)
- ws (для WebSocket)
- debug (для логирования)

---

## Приоритеты разработки

1. **Высокий приоритет:**
   - Базовая архитектура
   - Яндекс.Карты провайдер
   - Основной компонент Geo
   - Безопасные API роуты

2. **Средний приоритет:**
   - Google Maps провайдер
   - 2GIS провайдер
   - Маркеры
   - Главная страница

3. **Низкий приоритет:**
   - Полигоны
   - Маршруты
   - Дополнительные возможности
   - Оптимизация производительности

---

## Критерии готовности

- [ ] Все три провайдера работают
- [ ] Компонент Geo экспортируется из npm пакета
- [ ] Главная страница демонстрирует все возможности
- [ ] Генератор кода работает корректно
- [ ] Все тесты проходят
- [ ] Документация полная
- [ ] Пакет опубликован в npm

---

## Примечания

- Работать поэтапно, начиная с одного провайдера (Яндекс.Карты)
- Обязательно читать CONTRIBUTING.md файл при работе с Hasyx
- Все API токены должны быть защищены и не передаваться на клиент
- Использовать TypeScript для типизации всех компонентов и API
- Следовать принципам shadcn/ui для консистентности интерфейса
- Использовать Hasyx систему логирования для отладки (`DEBUG="geo*"`)
- Интегрировать с Hasyx CLI системой для удобства разработки
- Следовать архитектуре Hasyx для совместимости и расширяемости
- Использовать Hasyx систему событий для real-time функциональности
- Интегрировать с Hasyx системой миграций для управления схемой БД 